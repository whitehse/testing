//#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stddef.h>
#include <spreadsheetmlrw.h>

//#include <mz_compat.h>
#include <zip.h>
#include <unzip.h>

#define BUF_SIZE 8192
#define MAX_NAMELEN 256

struct str_builder;
typedef struct str_builder str_builder_t;

str_builder_t *str_builder_create(void);
void str_builder_destroy(str_builder_t *sb);
void str_builder_add_str(str_builder_t *sb, const char *str, size_t len);
void str_builder_add_char(str_builder_t *sb, char c);
void str_builder_add_int(str_builder_t *sb, int val);
void str_builder_clear(str_builder_t *sb);
void str_builder_truncate(str_builder_t *sb, size_t len);
void str_builder_drop(str_builder_t *sb, size_t len);
size_t str_builder_len(const str_builder_t *sb);
const char *str_builder_peek(const str_builder_t *sb);
char *str_builder_dump(const str_builder_t *sb, size_t *len);
static const size_t str_builder_min_size = 32;

struct str_builder {
    char   *str;
    size_t  alloced;
    size_t  len;
};

str_builder_t *str_builder_create(void)
{
    str_builder_t *sb;

    sb          = calloc(1, sizeof(*sb));
    sb->str     = malloc(str_builder_min_size);
    *sb->str    = '\0';
    sb->alloced = str_builder_min_size;
    sb->len     = 0;

    return sb;
}

void str_builder_destroy(str_builder_t *sb)
{
    if (sb == NULL)
        return;
    free(sb->str);
    free(sb);
}

static void str_builder_ensure_space(str_builder_t *sb, size_t add_len)
{
    if (sb == NULL || add_len == 0)
        return;

    if (sb->alloced >= sb->len+add_len+1)
        return;

    while (sb->alloced < sb->len+add_len+1) {
        /* Doubling growth strategy. */
        sb->alloced <<= 1;
        if (sb->alloced == 0) {
            /* Left shift of max bits will go to 0. An unsigned type set to
             * -1 will return the maximum possible size. However, we should
             *  have run out of memory well before we need to do this. Since
             *  this is the theoretical maximum total system memory we don't
             *  have a flag saying we can't grow any more because it should
             *  be impossible to get to this point. */
            sb->alloced--;
        }
    }
    sb->str = realloc(sb->str, sb->alloced);
}

void str_builder_add_str(str_builder_t *sb, const char *str, size_t len)
{
    if (sb == NULL || str == NULL || *str == '\0')
        return;

    if (len == 0)
        len = strlen(str);

    str_builder_ensure_space(sb, len);
    memmove(sb->str+sb->len, str, len);
    sb->len += len;
    sb->str[sb->len] = '\0';
}

void str_builder_add_char(str_builder_t *sb, char c)
{
    if (sb == NULL)
        return;
    str_builder_ensure_space(sb, 1);
    sb->str[sb->len] = c;
    sb->len++;
    sb->str[sb->len] = '\0';
}

void str_builder_add_int(str_builder_t *sb, int val)
{
    char str[12];

    if (sb == NULL)
        return;

    snprintf(str, sizeof(str), "%d", val);
    str_builder_add_str(sb, str, 0);
}

void str_builder_clear(str_builder_t *sb)
{
    if (sb == NULL)
        return;
    str_builder_truncate(sb, 0);
}

void str_builder_truncate(str_builder_t *sb, size_t len)
{
    if (sb == NULL || len >= sb->len)
        return;

    sb->len = len;
    sb->str[sb->len] = '\0';
}

void str_builder_drop(str_builder_t *sb, size_t len)
{
    if (sb == NULL || len == 0)
        return;

    if (len >= sb->len) {
        str_builder_clear(sb);
        return;
    }

    sb->len -= len;
    /* +1 to move the NULL. */
    memmove(sb->str, sb->str+len, sb->len+1);
}

size_t str_builder_len(const str_builder_t *sb)
{
    if (sb == NULL)
        return 0;
    return sb->len;
}

const char *str_builder_peek(const str_builder_t *sb)
{
    if (sb == NULL)
        return NULL;
    return sb->str;
}

char *str_builder_dump(const str_builder_t *sb, size_t *len)
{
    char *out;

    if (sb == NULL)
        return NULL;

    if (len != NULL)
        *len = sb->len;
    out = malloc(sb->len+1);
    memcpy(out, sb->str, sb->len+1);
    return out;
}

typedef enum {
    ZIPPER_RESULT_ERROR = 0,
    ZIPPER_RESULT_SUCCESS,
    ZIPPER_RESULT_SUCCESS_EOF
} zipper_result_t;

typedef void (*zipper_read_cb_t)(const unsigned char *buf, size_t size, void *thunk);

bool zipper_add_file(zipFile zfile, const char *filename);
bool zipper_add_buf(zipFile zfile, const char *zfilename, const unsigned char *buf, size_t buflen);
bool zipper_add_dir(zipFile zfile, const char *dirname);

zipper_result_t zipper_read(unzFile zfile, zipper_read_cb_t cb, void *thunk);
zipper_result_t zipper_read_buf(unzFile zfile, unsigned char **buf, size_t *buflen);

bool zipper_skip_file(unzFile zfile);
char *zipper_filename(unzFile zfile, bool *isutf8);
bool zipper_isdir(unzFile zfile);
uint64_t zipper_filesize(unzFile zfile);

bool zipper_add_file(zipFile zfile, const char *filename)
{
    FILE          *f;
    unsigned char  buf[BUF_SIZE];
    int            ret;
    size_t         red;
    size_t         flen;

    if (zfile == NULL || filename == NULL)
        return false;

    f = fopen(filename, "r");
    if (f == NULL)
        return false;

    fseek(f, 0, SEEK_END);
    flen = ftell(f);
    rewind(f);

    ret = zipOpenNewFileInZip64(zfile, filename, NULL, NULL, 0, NULL, 0, NULL,
            Z_DEFLATED, Z_DEFAULT_COMPRESSION, (flen > 0xffffffff)?1:0);
    if (ret != ZIP_OK) {
        fclose(f);
        return false;
    }

    while ((red = fread(buf, sizeof(*buf), sizeof(buf), f)) > 0) {
        ret = zipWriteInFileInZip(zfile, buf, red);
        if (ret != ZIP_OK) {
            fclose(f);
            zipCloseFileInZip(zfile);
            return false;
        }
    }

    zipCloseFileInZip(zfile);
    return true;
}

bool zipper_add_buf(zipFile zfile, const char *zfilename, const unsigned char *buf, size_t buflen)
{
    int ret;

    if (zfile == NULL || buf == NULL || buflen == 0)
        return false;

    ret = zipOpenNewFileInZip64(zfile, zfilename, NULL, NULL, 0, NULL, 0, NULL,
            Z_DEFLATED, Z_DEFAULT_COMPRESSION, (buflen > 0xffffffff)?1:0);
    if (ret != ZIP_OK)
        return false;

    ret = zipWriteInFileInZip(zfile, buf, buflen);
    zipCloseFileInZip(zfile);
    return ret==ZIP_OK?true:false;
}

bool zipper_add_dir(zipFile zfile, const char *dirname)
{
    char   *temp;
    size_t  len;
    int     ret;

    if (zfile == NULL || dirname == NULL || *dirname == '\0')
        return false; 

    len  = strlen(dirname);
    temp = calloc(1, len+2);
    memcpy(temp, dirname, len+2);
    if (temp[len-1] != '/') {
        temp[len] = '/';
        temp[len+1] = '\0';
    } else {
        temp[len] = '\0';
    }

    ret = zipOpenNewFileInZip64(zfile, temp, NULL, NULL, 0, NULL, 0, NULL, 0, 0, 0);
    if (ret != ZIP_OK)
        return false;
    free(temp);
    zipCloseFileInZip(zfile);
    return ret==ZIP_OK?true:false;
}

zipper_result_t zipper_read(unzFile zfile, zipper_read_cb_t cb, void *thunk)
{
    unsigned char tbuf[BUF_SIZE];
    int           red;
    int           ret;

    if (zfile == NULL || cb == NULL)
        return ZIPPER_RESULT_ERROR;

    ret = unzOpenCurrentFile(zfile);
    if (ret != UNZ_OK)
        return ZIPPER_RESULT_ERROR;

    while ((red = unzReadCurrentFile(zfile, tbuf, sizeof(tbuf))) > 0) {
        cb(tbuf, red, thunk);
    }

    if (red < 0) {
        unzCloseCurrentFile(zfile);
        return ZIPPER_RESULT_ERROR;
    }

    unzCloseCurrentFile(zfile);
    if (unzGoToNextFile(zfile) != UNZ_OK)
        return ZIPPER_RESULT_SUCCESS_EOF;
    return ZIPPER_RESULT_SUCCESS;
}

static void zipper_read_buf_cb(const unsigned char *buf, size_t buflen, void *thunk)
{
    str_builder_t *sb = thunk;
    str_builder_add_str(sb, (const char *)buf, buflen);
}

zipper_result_t zipper_read_buf(unzFile zfile, unsigned char **buf, size_t *buflen)
{
    str_builder_t   *sb;
    zipper_result_t  ret;

    sb = str_builder_create();
    ret = zipper_read(zfile, zipper_read_buf_cb, sb);
    if (ret != ZIPPER_RESULT_ERROR)
        *buf = (unsigned char *)str_builder_dump(sb, buflen);
    str_builder_destroy(sb);
    return ret;
}

char *zipper_filename(unzFile zfile, bool *isutf8)
{
    char            name[MAX_NAMELEN];
    unz_file_info64 finfo;
    int             ret;

    if (zfile == NULL)
        return NULL;

    ret = unzGetCurrentFileInfo64(zfile, &finfo, name, sizeof(name), NULL, 0, NULL, 0);
    if (ret != UNZ_OK)
        return NULL;
    if (isutf8 != NULL)
        *isutf8 = (finfo.flag & (1<<11))?true:false;
    return strdup(name);
}

bool zipper_isdir(unzFile zfile)
{
    char            name[MAX_NAMELEN];
    unz_file_info64 finfo;
    size_t          len;
    int             ret;

    if (zfile == NULL)
        return false;

    ret = unzGetCurrentFileInfo64(zfile, &finfo, name, sizeof(name), NULL, 0, NULL, 0);
    if (ret != UNZ_OK)
        return false;

    len = strlen(name);
    if (finfo.uncompressed_size == 0 && len > 0 && name[len-1] == '/')
        return true;
    return false;
}

bool zipper_skip_file(unzFile zfile)
{
    if (unzGoToNextFile(zfile) != UNZ_OK)
        return false;
    return true;
}

uint64_t zipper_filesize(unzFile zfile)
{
    unz_file_info64 finfo;
    int             ret;

    if (zfile == NULL)
        return 0;

    ret = unzGetCurrentFileInfo64(zfile, &finfo, NULL, 0, NULL, 0, NULL, 0);
    if (ret != UNZ_OK)
        return 0;
    return finfo.uncompressed_size;
}

int main() {
   puts("Hello, World!");
   struct ml_type_parse *ml_type_parser;
   ml_type_parser = in_word_set_ml_type ("application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml", 73);
   printf("Name = %s\n", ml_type_parser->name);
   printf("Enum = %d\n", (int)ml_type_parser->ml_type);
   ml_type_parser = in_word_set_ml_type ("application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml", 74);
   printf("Name = %s\n", ml_type_parser->name);
   printf("Enum = %d\n", (int)ml_type_parser->ml_type);



   return 0;
}
