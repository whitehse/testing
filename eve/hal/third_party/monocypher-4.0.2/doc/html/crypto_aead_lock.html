<!DOCTYPE html>
<html>
<!-- This is an automatically generated file.  Do not edit.
   This file is dual-licensed.  Choose whichever you want.
  
   The first licence is a regular 2-clause BSD licence.  The second licence
   is the CC-0 from Creative Commons. It is intended to release Monocypher
   to the public domain.  The BSD licence serves as a fallback option.
  
   SPDX-License-Identifier: BSD-2-Clause OR CC0-1.0
  
   ----------------------------------------------------------------------------
  
   Copyright (c) 2017-2019, 2023 Loup Vaillant
   Copyright (c) 2017-2018 Michael Savage
   Copyright (c) 2017, 2019-2022 Fabio Scotoni
   All rights reserved.
  
   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:
  
   1. Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
  
   2. Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the
      distribution.
  
   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  
   ----------------------------------------------------------------------------
  
   Written in 2017-2023 by Loup Vaillant, Michael Savage and Fabio Scotoni
  
   To the extent possible under law, the author(s) have dedicated all copyright
   and related neighboring rights to this software to the public domain
   worldwide.  This software is distributed without any warranty.
  
   You should have received a copy of the CC0 Public Domain Dedication along
   with this software.  If not, see
   <https://creativecommons.org/publicdomain/zero/1.0/>
   -->
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="style.css" type="text/css" media="all"/>
  <title>CRYPTO_LOCK(3MONOCYPHER)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">CRYPTO_LOCK(3MONOCYPHER)</td>
    <td class="head-vol">3MONOCYPHER</td>
    <td class="head-rtitle">CRYPTO_LOCK(3MONOCYPHER)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp"><code class="Nm">crypto_aead_lock</code>,
    <code class="Nm">crypto_aead_unlock</code>,
    <code class="Nm">crypto_aead_init_x</code>,
    <code class="Nm">crypto_aead_init_djb</code>,
    <code class="Nm">crypto_aead_init_ietf</code>,
    <code class="Nm">crypto_aead_write</code>,
    <code class="Nm">crypto_aead_read</code> &#x2014;
    <span class="Nd">authenticated encryption with additional data</span></p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><code class="In">#include
    &lt;<a class="In">monocypher.h</a>&gt;</code></p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_aead_lock</code>(<var class="Fa">uint8_t
    *cipher_text</var>, <var class="Fa">uint8_t mac[16]</var>,
    <var class="Fa">const uint8_t key[32]</var>, <var class="Fa">const uint8_t
    nonce[24]</var>, <var class="Fa">const uint8_t *ad</var>,
    <var class="Fa">size_t ad_size</var>, <var class="Fa">const uint8_t
    *plain_text</var>, <var class="Fa">size_t text_size</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">crypto_aead_unlock</code>(<var class="Fa">uint8_t
    *plain_text</var>, <var class="Fa">const uint8_t mac[16]</var>,
    <var class="Fa">const uint8_t key[32]</var>, <var class="Fa">const uint8_t
    nonce[24]</var>, <var class="Fa">const uint8_t *ad</var>,
    <var class="Fa">size_t ad_size</var>, <var class="Fa">const uint8_t
    *cipher_text</var>, <var class="Fa">size_t text_size</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_aead_init_x</code>(<var class="Fa">crypto_aead_ctx
    *ctx</var>, <var class="Fa">const uint8_t key[32]</var>,
    <var class="Fa">const uint8_t nonce[24]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_aead_init_djb</code>(<var class="Fa">crypto_aead_ctx
    *ctx</var>, <var class="Fa">const uint8_t key[32]</var>,
    <var class="Fa">const uint8_t nonce[8]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_aead_init_ietf</code>(<var class="Fa">crypto_aead_ctx
    *ctx</var>, <var class="Fa">const uint8_t key[32]</var>,
    <var class="Fa">const uint8_t nonce[12]</var>);</p>
<p class="Pp"><var class="Ft">void</var>
  <br/>
  <code class="Fn">crypto_aead_write</code>(<var class="Fa">crypto_aead_ctx
    *ctx</var>, <var class="Fa">uint8_t *cipher_text</var>,
    <var class="Fa">uint8_t mac[16]</var>, <var class="Fa">const uint8_t
    *ad</var>, <var class="Fa">size_t ad_size</var>, <var class="Fa">const
    uint8_t *plain_text</var>, <var class="Fa">size_t text_size</var>);</p>
<p class="Pp"><var class="Ft">int</var>
  <br/>
  <code class="Fn">crypto_aead_read</code>(<var class="Fa">crypto_aead_ctx
    *ctx</var>, <var class="Fa">uint8_t *plain_text</var>, <var class="Fa">const
    uint8_t mac[16]</var>, <var class="Fa">const uint8_t *ad</var>,
    <var class="Fa">size_t ad_size</var>, <var class="Fa">const uint8_t
    *cipher_text</var>, <var class="Fa">size_t text_size</var>);</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><a class="permalink" href="#crypto_aead_lock"><code class="Fn" id="crypto_aead_lock">crypto_aead_lock</code></a>()
    encrypts and authenticates a plaintext. It can be decrypted by
    <code class="Fn">crypto_aead_unlock</code>(). The arguments are:</p>
<dl class="Bl-tag">
  <dt><var class="Fa">key</var></dt>
  <dd>A 32-byte session key shared between the sender and the recipient. It must
      be secret and random. Different methods can be used to produce and
      exchange this key, such as Diffie-Hellman key exchange, password-based key
      derivation (the password must be communicated on a secure channel), or
      even meeting physically. See
      <a class="Xr" href="crypto_x25519.html">crypto_x25519(3monocypher)</a> for
      a building block for a key exchange protocol and
      <a class="Xr" href="crypto_argon2.html">crypto_argon2(3monocypher)</a> for
      password-based key derivation.</dd>
  <dt id="Never"><var class="Fa">nonce</var></dt>
  <dd>A 24-byte number, used only once with any given session key. It does not
      need to be secret or random, but it does have to be unique.
      <a class="permalink" href="#Never"><i class="Em">Never</i></a> use the
      same nonce twice with the same key. This would basically reveal the
      affected messages and leave you vulnerable to forgeries. The easiest (and
      recommended) way to generate this nonce is to select it at random. See
      <a class="Xr" href="intro.html">intro(3monocypher)</a> about random number
      generation (use your operating system's random number generator).
    <p class="Pp" id="crypto_aead_init_djb">Note:
        <a class="permalink" href="#crypto_aead_init_djb"><code class="Fn">crypto_aead_init_djb</code></a>()
        and <code class="Fn">crypto_aead_init_ietf</code>() use shorter nonces
        (8 and 12 bytes respectively), which
        <a class="permalink" href="#cannot"><i class="Em" id="cannot">cannot</i></a>
        be selected at random without risking a catastrophic reuse. For those
        shorter nonces, use a counter instead.</p>
  </dd>
  <dt id="message"><var class="Fa">mac</var></dt>
  <dd>A 16-byte <a class="permalink" href="#message"><i class="Em">message
      authentication code</i></a> (MAC) that can only be produced by someone who
      knows the session key. This guarantee cannot be upheld if a nonce has been
      reused with the session key because doing so allows the attacker to learn
      the authentication key associated with that nonce. The MAC is intended to
      be sent along with the ciphertext.</dd>
  <dt><var class="Fa">ad</var></dt>
  <dd>Additional data to authenticate. It will <i class="Em">not</i> be
      encrypted. This is used to authenticate relevant data that cannot be
      encrypted. May be <code class="Dv">NULL</code> if
      <var class="Fa">ad_size</var> is zero.</dd>
  <dt><var class="Fa">ad_size</var></dt>
  <dd>Length of the additional data, in bytes.</dd>
  <dt><var class="Fa">plain_text</var></dt>
  <dd>The secret message. Its contents will be kept hidden from attackers. Its
      length, however, will <i class="Em">not</i>. Be careful when combining
      encryption with compression. See
      <a class="Xr" href="intro.html">intro(3monocypher)</a> for details.</dd>
  <dt><var class="Fa">cipher_text</var></dt>
  <dd>The encrypted message.</dd>
  <dt><var class="Fa">text_size</var></dt>
  <dd>Length of both <var class="Fa">plain_text and</var>
      <var class="Fa">cipher_text</var>, in bytes.</dd>
</dl>
<p class="Pp">The <var class="Fa">cipher_text</var> and
    <var class="Fa">plain_text</var> arguments may point to the same buffer for
    in-place encryption. Otherwise, the buffers they point to must not
  overlap.</p>
<p class="Pp" id="crypto_aead_unlock"><a class="permalink" href="#crypto_aead_unlock"><code class="Fn">crypto_aead_unlock</code></a>()
    first checks the integrity of an encrypted message. If it has been
    corrupted, <code class="Fn">crypto_aead_unlock</code>() does nothing and
    returns -1 immediately. Otherwise it decrypts the message then returns zero.
    <i class="Em">Always check the return value</i>.</p>
<section class="Ss">
<h2 class="Ss" id="Incremental_interface"><a class="permalink" href="#Incremental_interface">Incremental
  interface</a></h2>
<p class="Pp">For long messages that may not fit in memory, first initialise a
    context with
    <a class="permalink" href="#crypto_aead_init_x"><code class="Fn" id="crypto_aead_init_x">crypto_aead_init_x</code></a>(),
    then encrypt each chunk with
    <a class="permalink" href="#crypto_aead_write"><code class="Fn" id="crypto_aead_write">crypto_aead_write</code></a>().
    The receiving end will initialise its own context with
    <code class="Fn">crypto_aead_init_x</code>(), then decrypt each chunk with
    <code class="Fn">crypto_aead_read</code>().</p>
<p class="Pp" id="crypto_aead_unlock~2">Just like
    <a class="permalink" href="#crypto_aead_unlock~2"><code class="Fn">crypto_aead_unlock</code></a>(),
    <code class="Fn">crypto_aead_read</code>() first checks the integrity of the
    encrypted chunk, then returns -1 immediately if it has been corrupted.
    Otherwise it decrypts the chunk then returns zero. <i class="Em">Always
    check the return value</i>.</p>
<p class="Pp" id="crypto_aead_read">The encryption key is changed between each
    chunk, providing a symmetric ratchet that enforces the order of the
    messages. Attackers cannot reorder chunks without
    <a class="permalink" href="#crypto_aead_read"><code class="Fn">crypto_aead_read</code></a>()
    noticing.
    <a class="permalink" href="#Truncation"><b class="Sy" id="Truncation">Truncation
    however is not detected</b></a>. You must detect the last chunk manually.
    Possible methods include using <var class="Fa">ad</var> to mark the last
    chunk differently, prefixing all plaintext messages with a marking byte (and
    use a different marking byte for the last chunk), or sending the total
    message size up front and encode the remaining size in
    <var class="Fa">ad</var>. Once the last chunk is sent or received, wipe the
    context with
    <a class="Xr" href="crypto_wipe.html">crypto_wipe(3monocypher)</a>.</p>
<p class="Pp" id="crypto_aead_init_djb~2"><a class="permalink" href="#crypto_aead_init_djb~2"><code class="Fn">crypto_aead_init_djb</code></a>()
    and <code class="Fn">crypto_aead_init_ietf</code>() are variants of
    <a class="permalink" href="#crypto_aead_init_x~2"><code class="Fn" id="crypto_aead_init_x~2">crypto_aead_init_x</code></a>()
    with a shorter nonce.
    <a class="permalink" href="#Those"><i class="Em" id="Those">Those nonces are
    too short to be selected at random</i></a>. Use a counter instead.</p>
<p class="Pp" id="crypto_aead_init_ietf">In addition to its short nonce,
    <a class="permalink" href="#crypto_aead_init_ietf"><code class="Fn">crypto_aead_init_ietf</code></a>()
    has a smaller internal counter that limits the size of chunks to 256GiB.
    Exceeding this size leaks the contents of the chunk. It is provided strictly
    for compatibility with RFC 8439.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUES"><a class="permalink" href="#RETURN_VALUES">RETURN
  VALUES</a></h1>
<p class="Pp"><code class="Fn">crypto_aead_lock</code>(),
    <code class="Fn">crypto_aead_init_x</code>(),
    <code class="Fn">crypto_aead_init_djb</code>(),
    <code class="Fn">crypto_aead_init_ietf</code>(), and
    <code class="Fn">crypto_aead_write</code>() return nothing.
    <code class="Fn">crypto_aead_unlock</code>() and
    <code class="Fn">crypto_aead_read</code>() return 0 on success or -1 if the
    message was corrupted (i.e. <var class="Fa">mac</var> mismatched the
    combination of <var class="Fa">key</var>, <var class="Fa">nonce</var>,
    <var class="Fa">ad</var>, and <var class="Fa">cipher_text</var>). Corruption
    can be caused by transmission errors, programmer error, or an attacker's
    interference. <var class="Fa">plain_text</var> does not need to be wiped if
    the decryption fails.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The following examples assume the existence of
    <code class="Fn">arc4random_buf</code>(), which fills the given buffer with
    cryptographically secure random bytes. If
    <code class="Fn">arc4random_buf</code>() does not exist on your system, see
    <a class="Xr" href="intro.html">intro(3monocypher)</a> for advice about how
    to generate cryptographically secure random bytes.</p>
<p class="Pp">Encryption:</p>
<div class="Bd Pp Bd-indent Li">
<pre>uint8_t key        [32];    /* Random, secret session key  */
uint8_t nonce      [24];    /* Use only once per key       */
uint8_t plain_text [12] = &quot;Lorem ipsum&quot;; /* Secret message */
uint8_t mac        [16];    /* Message authentication code */
uint8_t cipher_text[12];              /* Encrypted message */
arc4random_buf(key,   32);
arc4random_buf(nonce, 24);
crypto_aead_lock(cipher_text, mac,
                 key, nonce,
                 NULL, 0,
                 plain_text, sizeof(plain_text));
/* Wipe secrets if they are no longer needed */
crypto_wipe(plain_text, 12);
crypto_wipe(key, 32);
/* Transmit cipher_text, nonce, and mac over the network,
 * store them in a file, etc.
 */</pre>
</div>
<p class="Pp">To decrypt the above:</p>
<div class="Bd Pp Bd-indent Li">
<pre>uint8_t       key        [32]; /* Same as the above        */
uint8_t       nonce      [24]; /* Same as the above        */
const uint8_t cipher_text[12]; /* Encrypted message        */
const uint8_t mac        [16]; /* Received along with text */
uint8_t       plain_text [12]; /* Secret message           */
if (crypto_aead_unlock(plain_text, mac,
                       key, nonce,
                       NULL, 0,
                       cipher_text, sizeof(plain_text))) {
    /* The message is corrupted.
     * Wipe key if it is no longer needed,
     * and abort the decryption.
     */
    crypto_wipe(key, 32);
} else {
    /* ...do something with the decrypted text here... */
    /* Finally, wipe secrets if they are no longer needed */
    crypto_wipe(plain_text, 12);
    crypto_wipe(key, 32);
}</pre>
</div>
<p class="Pp">In-place encryption:</p>
<div class="Bd Pp Bd-indent Li">
<pre>uint8_t key  [32];    /* Random, secret session key  */
uint8_t nonce[24];    /* Use only once per key       */
uint8_t text [12] = &quot;Lorem ipsum&quot;; /* Secret message */
uint8_t mac  [16];    /* Message authentication code */
arc4random_buf(key,   32);
arc4random_buf(nonce, 24);
crypto_aead_lock(text, mac,
                 key, nonce,
                 NULL, 0,
                 text, sizeof(text));
/* Wipe secrets if they are no longer needed */
crypto_wipe(key, 32);
/* Transmit cipher_text, nonce, and mac over the network,
 * store them in a file, etc.
 */</pre>
</div>
<p class="Pp">In-place decryption:</p>
<div class="Bd Pp Bd-indent Li">
<pre>uint8_t        key  [32]; /* Same as the above             */
const uint8_t  nonce[24]; /* Same as the above             */
const uint8_t  mac  [16]; /* Received from along with text */
uint8_t        text [12]; /* Message to decrypt            */
if (crypto_aead_unlock(text, mac, key, nonce,
                       NULL, 0,
                       text, sizeof(text))) {
	/* The message is corrupted.
	 * Wipe key if it is no longer needed,
	 * and abort the decryption.
	 */
	crypto_wipe(key, 32);
} else {
	/* ...do something with the decrypted text here... */
	/* Finally, wipe secrets if they are no longer needed */
	crypto_wipe(text, 12);
	crypto_wipe(key, 32);
}</pre>
</div>
<p class="Pp">Encrypt one message with the incremental interface:</p>
<div class="Bd Pp Bd-indent Li">
<pre>uint8_t key        [32];    /* Random, secret session key  */
uint8_t nonce      [24];    /* Use only once per key       */
uint8_t plain_text [12] = &quot;Lorem ipsum&quot;; /* Secret message */
uint8_t mac        [16];    /* Message authentication code */
uint8_t cipher_text[12];              /* Encrypted message */
arc4random_buf(key,   32);
arc4random_buf(nonce, 24);
crypto_aead_ctx ctx;
crypto_aead_init_x(&amp;ctx, key, nonce);
crypto_aead_write(&amp;ctx, cipher_text, mac,
                  NULL, 0,
                  plain_text, sizeof(plain_text));
/* Wipe secrets if they are no longer needed */
crypto_wipe(plain_text, 12);
crypto_wipe(key, 32);
crypto_wipe(&amp;ctx, sizeof(ctx));
/* Transmit cipher_text, nonce, and mac over the network,
 * store them in a file, etc.
 */</pre>
</div>
<p class="Pp">To decrypt the above:</p>
<div class="Bd Pp Bd-indent Li">
<pre>uint8_t       key        [32]; /* Same as the above        */
uint8_t       nonce      [24]; /* Same as the above        */
const uint8_t cipher_text[12]; /* Encrypted message        */
const uint8_t mac        [16]; /* Received along with text */
uint8_t       plain_text [12]; /* Secret message           */
crypto_aead_ctx ctx;
crypto_aead_init_x(&amp;ctx, key, nonce);
if (crypto_aead_read(&amp;ctx, plain_text, mac,
                     NULL, 0,
                     cipher_text, sizeof(plain_text))) {
	/* The message is corrupted.
	 * Wipe key if it is no longer needed,
	 * and abort the decryption.
	 */
	crypto_wipe(key, 32);
	crypto_wipe(&amp;ctx, sizeof(ctx));
} else {
	/* ...do something with the decrypted text here... */
	/* Finally, wipe secrets if they are no longer needed */
	crypto_wipe(plain_text, 12);
	crypto_wipe(key, 32);
	crypto_wipe(&amp;ctx, sizeof(ctx));
}</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><a class="Xr" href="crypto_x25519.html">crypto_x25519(3monocypher)</a>,
    <a class="Xr" href="crypto_wipe.html">crypto_wipe(3monocypher)</a>,
    <a class="Xr" href="intro.html">intro(3monocypher)</a></p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">These functions implement RFC 8439.
    <code class="Fn">crypto_aead_lock</code>() and
    <code class="Fn">crypto_aead_init_x</code>(), use XChaCha20 instead of
    ChaCha20. <code class="Fn">crypto_aead_init_djb</code>() uses a 64-bit nonce
    and a 64-bit counter. <code class="Fn">crypto_aead_init_ietf</code>() is
    fully compatible with the RFC. Note that XChaCha20 derives from ChaCha20 the
    same way XSalsa20 derives from Salsa20 and benefits from the same security
    reduction (proven secure as long as ChaCha20 itself is secure).</p>
<p class="Pp"><code class="Fn">crypto_aead_read</code>() and
    <code class="Fn">crypto_aead_write</code>() preserve the nonce and counter
    defined in <code class="Fn">crypto_aead_init_x</code>(),
    <code class="Fn">crypto_aead_init_djb</code>(), or
    <code class="Fn">crypto_aead_init_ietf</code>(), and instead change the
    session key. The new session key is made from bytes [32..63] of the ChaCha20
    stream used to generate the authentication key and encrypt the message.
    (Recall that bytes [0..31] are the authentication key, and bytes [64..] are
    used to encrypt the message.)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HISTORY"><a class="permalink" href="#HISTORY">HISTORY</a></h1>
<p class="Pp">The <code class="Fn">crypto_lock</code>() and
    <code class="Fn">crypto_unlock</code>() functions first appeared in
    Monocypher 0.1. <code class="Fn">crypto_lock_aead</code>() and
    <code class="Fn">crypto_unlock_aead</code>() were introduced in Monocypher
    1.1.0. In Monocypher 2.0.0, the underlying algorithms for these functions
    were changed from a custom XChaCha20/Poly1305 construction to an
    implementation of RFC 7539 (now RFC 8439) with XChaCha20 instead of
    ChaCha20. The <code class="Fn">crypto_lock_encrypt</code>() and
    <code class="Fn">crypto_lock_auth</code>() functions were removed in
    Monocypher 2.0.0. In Monocypher 4.0.0, the
    <code class="Fn">crypto_lock</code>() and
    <code class="Fn">crypto_unlock</code>() were removed, Functions were renamed
    and arguments reordered for consistency, and the incremental interface was
    added.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="CAVEATS"><a class="permalink" href="#CAVEATS">CAVEATS</a></h1>
<p class="Pp">Monocypher does not perform any input validation. Any deviation
    from the specified input and output length ranges results in
    <a class="permalink" href="#undefined"><b class="Sy" id="undefined">undefined
    behaviour</b></a>. Make sure your inputs are correct.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">March 6, 2023</td>
    <td class="foot-os">Debian</td>
  </tr>
</table>
</body>
</html>
