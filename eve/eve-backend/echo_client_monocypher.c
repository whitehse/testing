#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>

#include <ev.h>
//#define EV_STANDALONE 1
//#include <ev.c>
#include <monocypher.h>
#include <cfgpath.h>

void stdin_read_cb(struct ev_loop *loop, struct ev_io *w, int revents){
  //char buffer[BUFFER_SIZE];
  ssize_t read;

  //PGconn* conn = (PGconn*)w->data;
}

int main(int argc, char const *argv[]) {
  struct ev_loop *loop = ev_default_loop(0);
  FILE *fptr;
  const uint8_t their_pk     [32]; /* Their public key          */
  uint8_t       your_sk      [32]; /* Your secret key           */
  uint8_t       your_pk      [32]; /* Your public key           */
  uint8_t       shared_secret[32]; /* Shared secret (NOT a key) */

  // client public key
  if ((fptr = fopen("client.pk","rb")) == NULL){
    printf("Error! opening file");
    exit(1);
  }
  fread(your_pk, 32, 1, fptr);
  fclose(fptr); 

  // client secret key
  if ((fptr = fopen("client.sk","rb")) == NULL){
    printf("Error! opening file");
    exit(1);
  }
  fread(&your_sk, 32, 1, fptr);
  fclose(fptr); 

  // server public key
  if ((fptr = fopen("server.pk","rb")) == NULL){
    printf("Error! opening file");
    exit(1);
  }
  fread(&their_pk, 32, 1, fptr);
  fclose(fptr); 

  crypto_x25519(shared_secret, your_sk, their_pk);
  /* Wipe secrets if they are no longer needed */
  crypto_wipe(your_sk, 32);

  uint8_t shared_keys[64]; /* Two shared session keys */
  crypto_blake2b_ctx ctx;
  crypto_blake2b_init  (&ctx, 64);
  crypto_blake2b_update(&ctx, shared_secret, 32);
  crypto_blake2b_update(&ctx, your_pk      , 32);
  crypto_blake2b_update(&ctx, their_pk     , 32);
  crypto_blake2b_final (&ctx, shared_keys);
  const uint8_t *k2 = shared_keys;      /* Shared key 1 */
  const uint8_t *k1 = shared_keys + 32; /* Shared key 2 */

  // First order of business is to create session keys. The first segment of
  // data (PDU) sent to the server will contain:
  //   uint64_t - unique client identifier (in clear text)
  //   uint8_t[32] - k1, the future chacha20 client session key used to encrypt
  //                 the 4 byte length of successive PDUs
  //   uint8_t[32] - k2, the future client session key used in conjuction with
  //                 poly1305 to contruct the AEAD of future PDUs
  //   uint8_t[32] - authentication cookie
  //   uint8_t[16] - message authentication code
  //
  // The total length of the initial PDU, including the client identifier, is
  // 122 bytes, by protocol, and does not use a length field.
  //
  // After authentication, the server will generate its own, separate, k1 and k2
  //
  // Note that the first four bytes, encrypted with k1, will become the Additional
  // Data of the AEAD PDU, of which the cyphertext portion will be encrypted with
  // k2. The encrypted length data will, eventually, be authenticated. However it
  // will first be decrypted, without authentication, to determine the length of
  // the cyphertext of the PDU. There is room for foul play should an attacker
  // corrupt the length. For example, the corruption could indicate a
  // very large PDU size, leading to eventual buffer exhaustion. A reasonable
  // upper limit should be set for the maximum length of a PDU, by protocol. The
  // MAC, transmitted after the cyphertext, will need to be in possession for the
  // entire PDU to be authenticated.
  //
  // The keys, k1 and k2, will be regenerated, or rotated, after each 1 gigabyte
  // of data transferred. This is independently calculated by the client and the
  // the server. That is, key rotation will occur asymmetrically and at different
  // times between the two directions of the connection.
  //
  // The authentication cookie is generated by the server and supplied by the
  // client on each authenticated connection. This will be used, by the server,
  // to control how often client/password authentication and/or TOTP multi-factor
  // authentication will be entered by the user. That is, if the authentication
  // cookie is, say, more than one week old, the server may require a new
  // multi-factor authentication code. Authentication policy will be
  // determined by the server system administrator. The client should send
  // an authentication cookie consisting of all zeros (32 bytes) on the first
  // authentication to the server, or should the client wish to reset
  // authentication state.
  //
  // The nonce will equal the number of cyphertext bytes transferred, and will
  // hence be unique for each AEAD PDU generated, per session key. It is used
  // to track when the 1 gigabyte threshold has been crossed and when key rotation
  // should occur. It is reset to zero each time the key is regenerated/rotated
  // (to be used in the subsequent PDU sent).
  //
  // However, the nonce will be randomly generated for the initial client
  // and server key rotation PDUs, which use the X25519 and blake2b
  // deterministically generated keys. Otherwise, a nonce of zero would be
  // reused for those keys each time a connection is established, leading to
  // doom.

  uint8_t initial_nonce [24]; /* randomly generated */
  uint8_t nonce         [24]; /* Use once per key, equal to bytes transferred */
  uint8_t mac           [16]; /* Message authentication code */  

  // Generate random nonce for initial key rotation
  getrandom(initial_nonce, 24, 0);
 
  // Zero out the nonce
  memset(nonce, 0, 24);

  // Create a 64-bit counter that points to the first 8 bytes of the nonce.
  // The last 16 bytes will always be zero.
  // Endianness of this value is whatever the local host uses.
  uint64_t *nonce_counter = (uint64_t *)&nonce;

  // To later be converted to network byte order, using htobe64();
  uint64_t client_id = 42;

  int serverFd;
  struct sockaddr_in server;
  int len;
  int port = 1234;
  char *server_ip = "127.0.0.1";
  char *buffer = "hello server";

  serverFd = socket(AF_INET, SOCK_STREAM, 0);
  if (serverFd < 0) {
    perror("Cannot create socket");
    exit(1);
  }
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = inet_addr(server_ip);
  server.sin_port = htons(port);
  len = sizeof(server);
  if (connect(serverFd, (struct sockaddr *)&server, len) < 0) {
    perror("Cannot connect to server");
    exit(2);
  }

  close(serverFd);

  /* Wipe secrets if they are no longer needed */
  crypto_wipe(shared_secret, 32);

  return 0;
}
