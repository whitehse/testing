#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <string.h>

#include <ev.h>
//#define EV_STANDALONE 1
//#include <ev.c>
#include <monocypher.h>
#include <cfgpath.h>

void hex_dump(char *desc, void *addr, int len) {
    int i;
    unsigned char buff[17];
    unsigned char *pc = (unsigned char*)addr;

    // Output description if given.
    if (desc != NULL)
        printf ("%s:\n", desc);

    // Process every byte in the data.
    for (i = 0; i < len; i++) {
        // Multiple of 16 means new line (with line offset).

        if ((i % 16) == 0) {
            // Just don't print ASCII for the zeroth line.
            if (i != 0)
                printf("  %s\n", buff);

            // Output the offset.
            printf("  %04x ", i);
        }

        // Now the hex code for the specific character.
        printf(" %02x", pc[i]);

        // And store a printable ASCII character for later.
        if ((pc[i] < 0x20) || (pc[i] > 0x7e)) {
            buff[i % 16] = '.';
        } else {
            buff[i % 16] = pc[i];
        }

        buff[(i % 16) + 1] = '\0';
    }

    // Pad out last line if not exactly 16 characters.
    while ((i % 16) != 0) {
        printf("   ");
        i++;
    }

    // And print the final ASCII bit.
    printf("  %s\n", buff);
}

void stdin_read_cb(struct ev_loop *loop, struct ev_io *w, int revents){
  //char buffer[BUFFER_SIZE];
  ssize_t read;

  //PGconn* conn = (PGconn*)w->data;
}

int main(int argc, char const *argv[]) {
  struct ev_loop *loop = ev_default_loop(0);
  FILE *fptr;
  const uint8_t their_pk     [32]; /* Their public key          */
  uint8_t       your_sk      [32]; /* Your secret key           */
  uint8_t       your_pk      [32]; /* Your public key           */
  uint8_t       shared_secret[32]; /* Shared secret (NOT a key) */

  // client public key
  if ((fptr = fopen("client.pk","rb")) == NULL){
    printf("Error! opening file");
    exit(1);
  }
  fread(your_pk, 32, 1, fptr);
  fclose(fptr); 

  // client secret key
  if ((fptr = fopen("client.sk","rb")) == NULL){
    printf("Error! opening file");
    exit(1);
  }
  fread(&your_sk, 32, 1, fptr);
  fclose(fptr); 

  // server public key
  if ((fptr = fopen("server.pk","rb")) == NULL){
    printf("Error! opening file");
    exit(1);
  }
  fread(&their_pk, 32, 1, fptr);
  fclose(fptr); 

  crypto_x25519(shared_secret, your_sk, their_pk);
  /* Wipe secrets if they are no longer needed */
  crypto_wipe(your_sk, 32);

  uint8_t shared_keys[64]; /* Two shared session keys */
  crypto_blake2b_ctx ctx;
  crypto_blake2b_init  (&ctx, 64);
  crypto_blake2b_update(&ctx, shared_secret, 32);
  crypto_blake2b_update(&ctx, your_pk      , 32);
  crypto_blake2b_update(&ctx, their_pk     , 32);
  crypto_blake2b_final (&ctx, shared_keys);
  hex_dump(NULL, shared_keys, 64);
  const uint8_t *client_initial_key = shared_keys;      /* Shared key 1 */
  const uint8_t *server_initial_key = shared_keys + 32; /* Shared key 2 */

  // First order of business is to create session keys. The first segment of
  // data (PDU) sent to the server will contain:
  //   uint64_t    - unique client identifier (in clear text)
  //   uint8_t[24] - Nonce, in clear text
  //   uint8_t[32] - k1, the future chacha20 client session key used to encrypt
  //                 the 4 byte length of successive PDUs
  //   uint8_t[32] - k2, the future client session key used in conjuction with
  //                 poly1305 to contruct the AEAD of future PDUs
  //   uint8_t[32] - authentication cookie
  //   uint8_t[16] - message authentication code
  //
  // The total length of the initial PDU, including the client identifier, is
  // 144 bytes, by protocol, and does not use a length field. The appended MAC
  //
  // After authentication, the server will generate its own, separate, k1 and k2
  //
  // Note that the first four bytes, encrypted with k1, will become the Additional
  // Data of the AEAD PDU, of which the cyphertext portion will be encrypted with
  // k2. The encrypted length data will, eventually, be authenticated. However it
  // will first be decrypted, without authentication, to determine the length of
  // the cyphertext of the PDU. There is room for foul play should an attacker
  // corrupt the length. For example, the corruption could indicate a
  // very large PDU size, leading to eventual buffer exhaustion. A reasonable
  // upper limit should be set for the maximum length of a PDU, by protocol. The
  // MAC, transmitted after the cyphertext, will need to be in possession for the
  // entire PDU to be authenticated.
  //
  // The keys, k1 and k2, will be regenerated, or rotated, after each 1 gigabyte
  // of data transferred. This is independently calculated by the client and the
  // the server. That is, key rotation will occur asymmetrically and at different
  // times between the two directions of the connection.
  //
  // The authentication cookie is generated by the server and supplied by the
  // client on each authenticated connection. This will be used, by the server,
  // to control how often client/password authentication and/or TOTP multi-factor
  // authentication will be entered by the user. That is, if the authentication
  // cookie is, say, more than one week old, the server may require a new
  // multi-factor authentication code. Authentication policy will be
  // determined by the server system administrator. The client should send
  // an authentication cookie consisting of all zeros (32 bytes) on the first
  // authentication to the server, or should the client wish to reset
  // authentication state.
  //
  // The nonce will equal the number of cyphertext bytes transferred, and will
  // hence be unique for each AEAD PDU generated, per session key. It is used
  // to track when the 1 gigabyte threshold has been crossed and when key rotation
  // should occur. It is reset to zero each time the key is regenerated/rotated
  // (to be used in the subsequent PDU sent).
  //
  // However, the nonce will be randomly generated for the initial client
  // and server key rotation PDUs, which use the X25519 and blake2b
  // deterministically generated keys. Otherwise, a nonce of zero would be
  // reused for those keys each time a connection is established, leading to
  // doom.

  //uint8_t initial_nonce [24]; /* randomly generated */
  uint8_t nonce         [24]; /* Use once per key, equal to bytes transferred */
  //uint8_t mac           [16]; /* Message authentication code */  
  uint8_t k1            [32];
  uint8_t k2            [32];
  uint8_t cookie        [32];

  // Generate new session keys from random data
  getrandom(k1, 32, 0);
  getrandom(k2, 32, 0);

  hex_dump("k1", k1, 32);
  hex_dump("k2", k2, 32);

  uint8_t buffer_initial [144];
  memset(buffer_initial, 0, 144);

  // Generate random nonce for initial PDU to server, which rotates the key(s)
  getrandom(buffer_initial+8, 24, 0);
  //memset(initial_nonce, 0, 24);
 
  // Zero out the nonce
  memset(nonce, 0, 24);

  // Zero out cookie 
  memset(cookie, 0, 32);

  // Create a 64-bit counter that points to the first 8 bytes of the nonce.
  // The last 16 bytes will always be zero.
  // Endianness of this value is whatever the local host uses.
  uint64_t *nonce_counter = (uint64_t *)&nonce;

  // To later be converted to network byte order, using htobe64();
  uint64_t client_id = htobe64(42);

  memcpy(buffer_initial, &client_id, 8);
  memcpy(buffer_initial+32, k1, 32);
  memcpy(buffer_initial+64, k2, 32);
  memcpy(buffer_initial+96, cookie, 32);

  // Encrypt the payload and add a MAC
  crypto_aead_lock(buffer_initial+32, buffer_initial+128,
                 client_initial_key, buffer_initial+8,
                 buffer_initial, 8,
                 buffer_initial+32, 96);

  //memcpy(buffer_initial+104, &mac, 16);

  printf("client id: %ju\n\n", client_id);
/*
  hex_dump(NULL, (void *) &buffer_initial, 144);
  puts("");
  hex_dump(NULL, (void *) &k1, 32);
  puts("");
  hex_dump(NULL, (void *) &k2, 32);
  puts("");
  hex_dump(NULL, (void *) &initial_nonce, 24);

  hex_dump(NULL, client_initial_key, 32);
*/

  int server_fd;
  struct sockaddr_in server;
  int len;
  int port = 1235;
  char *server_ip = "127.0.0.1";
  //char *buffer = "hello server";

  server_fd = socket(AF_INET, SOCK_STREAM, 0);
  if (server_fd < 0) {
    perror("Cannot create socket");
    exit(1);
  }
  server.sin_family = AF_INET;
  server.sin_addr.s_addr = inet_addr(server_ip);
  server.sin_port = htons(port);
  len = sizeof(server);
  if (connect(server_fd, (struct sockaddr *)&server, len) < 0) {
    perror("Cannot connect to server");
    exit(2);
  }

  int ret = write(server_fd, buffer_initial, 144);
  if (ret == -1) {
    perror("write error");
  }

  #define BUFFER_SIZE 1024
  char buffer[BUFFER_SIZE];
  ssize_t read;
  memset(buffer, 0, sizeof(buffer));
  //int size = read(w->fd, buffer, sizeof(buffer));
  read = recv(server_fd, buffer, BUFFER_SIZE, 0);
  if ( read <= 0 ) {
    perror("read error");
    exit(5);
  }
  
  hex_dump("Return from server", buffer, read);

  close(server_fd);

  /* Wipe secrets if they are no longer needed */
  crypto_wipe(shared_secret, 32);

  return 0;
}
